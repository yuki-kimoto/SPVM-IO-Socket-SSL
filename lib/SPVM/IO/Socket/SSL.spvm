# Copyright (c) 2024 Yuki Kimoto
# MIT License

class IO::Socket::SSL extends IO::Socket::IP {
  version "0.001";
  
  use IO::Socket::INET;
  use Net::SSLeay;
  use Net::SSLeay::SSL_CTX;
  use Net::SSLeay::SSL_METHOD;
  use Net::SSLeay::Constant as SSL;
  use Net::SSLeay::ERR;
  use Net::SSLeay::BIO;
  use Net::SSLeay::PEM;
  use StringBuffer;
  use Mozilla::CA;
  use Go;
  
  has ssl : Net::SSLeay;
  
  has ssl_options_h : Hash;
  
  # Class Methods
  static method new : IO::Socket::SSL ($options : object[] = undef) {
    
    my $self = new IO::Socket::SSL;
    
    $self->init($options);
    
    $self->configure;
    
    return $self;
  }
  
  # Instance Methods
  protected method option_names : string[] () {
    
    my $option_names = Array->merge_string(
      $self->SUPER::option_names,
      [
        "SSL_verify_mode",
        "SSL_hostname",
      ],
    );
    
    return $option_names;
  }
  
  protected method init : void ($options : object[] = undef) {
    
    my $options_h = Hash->new($options);
    
    $self->SUPER::init($options);
    
    my $ssl_options_h = Hash->new;
    
    my $verify_mode = $options_h->get_or_default_int("SSL_verify_mode", SSL->SSL_VERIFY_PEER);
    
    $ssl_options_h->set("SSL_verify_mode", $verify_mode);
    
    my $hostname = $options_h->get_or_default_string("SSL_hostname", undef);
    
    $ssl_options_h->set("SSL_hostname", $hostname);
    
    $self->{ssl_options_h} = $ssl_options_h;
  }
  
  protected method configure : void () {
    
    $self->SUPER::configure;
    
    $self->configure_SSL;
    
    # Client
    my $peer_address = $self->{PeerAddr};
    if ($peer_address) {
      $self->connect_SSL;
    }
  }
  
  protected method configure_SSL : void () {
    
    my $host = $self->{PeerAddr};
    
    my $is_client = 0;
    if ($host) {
      $is_client = 1;
    }
    
    my $ssl_method = Net::SSLeay::SSL_METHOD->SSLv23_client_method;
    
    my $ssl_ctx = Net::SSLeay::SSL_CTX->new($ssl_method);
    
    my $ssl_options_h = $self->{ssl_options_h};
    
    my $verify_mode = $ssl_options_h->get_int("SSL_verify_mode");
    
    $ssl_ctx->set_verify($verify_mode);
    
    my $ca = Mozilla::CA->SSL_ca;
    
    my $hostname = $ssl_options_h->get_string("SSL_hostname");
    
    unless ($hostname) {
      if ($host) {
        $hostname = $host;
      }
    }
    
    my $default_ssl_options = SSL->SSL_OP_ALL | SSL->SSL_OP_SINGLE_DH_USE | SSL->SSL_OP_SINGLE_ECDH_USE;
    
    my $ssl_options = $default_ssl_options;
    
    $ssl_ctx->set_default_verify_paths;
    
    my $bio = Net::SSLeay::BIO->new;
    
    $bio->write($ca);
    
    my $x509 = Net::SSLeay::PEM->read_bio_X509($bio);
    
    my $x509_store = $ssl_ctx->get_cert_store;
    
    $x509_store->add_cert($x509);
    
    my $verify_param = $ssl_ctx->get0_param;
    
    $verify_param->set_hostflags(SSL->X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS);
    
    $verify_param->set1_host($host);
    
    $ssl_ctx->set_options($default_ssl_options);
    
    my $ssl = Net::SSLeay->new($ssl_ctx);
    
    my $socket_fileno = $self->fileno;
    
    $ssl->set_fd($socket_fileno);
    
    if ($is_client) {
      $ssl->set_tlsext_host_name($host);
    }
    
    $self->{ssl} = $ssl;
  }
  
  protected method connect_SSL : void () {
    
    my $ssl = $self->{ssl};
    
    my $timeout = $self->{Timeout};
    
    my $fd = $self->{FD};
    
    while (1) {
      eval { $ssl->connect; }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_connect_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
  }
  
  method accept_SSL : void () {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    while (1) {
      eval { $ssl->accept; }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_accept_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
  }
  
  method accept : IO::Socket::SSL ($peer_ref : Sys::Socket::Sockaddr[] = undef) {
    my $client = (IO::Socket::SSL)$self->SUPER::accept($peer_ref);
    
    $self->accept_SSL;
    
    return $client;
  }
  
  method read : int ($buffer : mutable string, $length : int = -1, $offset : int = 0) {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $read_length = -1;
    while (1) {
      eval { $read_length = $ssl->read($buffer, $length, $offset); }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_read_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_read($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $read_length;
  }
  
  method write : int ($buffer : string, $length : int = -1, $offset : int = 0) {
    
    my $ssl = $self->{ssl};
    
    my $fd = $self->{FD};
    
    my $timeout = $self->{Timeout};
    
    my $write_length = -1;
    while (1) {
      
      eval { $write_length = $ssl->write($buffer, $length, $offset); }
      
      if ($@) {
        my $again = Sys::Socket::Errno->is_write_again(Sys::Socket::Errno->errno);
        
        if ($again) {
          Go->gosched_io_write($fd, $timeout);
          next;
        }
        else {
          die $@;
        }
      }
      else {
        last;
      }
    }
    
    return $write_length;
  }
  
  method close : void () {
    
    my $ssl = $self->{ssl};
    
    $ssl->shutdown;
    
    $self->SUPER::close;
    
  }
  
  method stat : Sys::IO::Stat () { die "stat method is not allowed in IO::Scoekt::SSL."; }
  
  method send : int ($buffer : string, $flags : int = 0, $length : int = -1, $offset : int = 0) {
    die "send method is not allowed in IO::Scoekt::SSL. Use write method instead.";
  }
  
  method sendto : int ($buffer : string, $flags : int, $to : Sys::Socket::Sockaddr, $length : int = -1, $offset : int = 0) {
    die "sendto method is not allowed in IO::Scoekt::SSL. Use write method instead.";
  }
  
  method recv : int ($buffer : mutable string, $length : int = -1, $flags : int = 0, $offset : int = 0) {
    die "recv method is not allowed in IO::Scoekt::SSL. Use read method instead.";
  }
  
  method recvfrom : int ($buffer : mutable string, $length : int, $flags : int, $from_ref : Sys::Socket::Sockaddr[], $offset : int = 0) {
    die "recvfrom method is not allowed in IO::Scoekt::SSL. Use read method instead.";
  }
}

